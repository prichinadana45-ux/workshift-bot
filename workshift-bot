import os
import sqlite3
import asyncio
from datetime import datetime, timedelta
from aiogram import Bot, Dispatcher, types
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup

# === –ù–ê–°–¢–†–û–ô–ö–ò ===
BOT_TOKEN = os.getenv("BOT_TOKEN")  # ‚Üê —Ç–æ–∫–µ–Ω –±—É–¥–µ—Ç –±—Ä–∞—Ç—å—Å—è –∏–∑ Railway
ADMIN_IDS = [794753395]  # ‚Üê —Ç–≤–æ–π ID

# –°–ø–∏—Å–∫–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞
POSITIONS = ["–°–ª–µ—Å–∞—Ä—å", "–¢–æ–∫–∞—Ä—å", "–°–≤–∞—Ä—â–∏–∫", "–≠–ª–µ–∫—Ç—Ä–∏–∫", "–ù–∞–ª–∞–¥—á–∏–∫"]
SECTIONS = ["–£—á–∞—Å—Ç–æ–∫-1", "–£—á–∞—Å—Ç–æ–∫-2", "–£—á–∞—Å—Ç–æ–∫-3", "–£—á–∞—Å—Ç–æ–∫-4", "–°–±–æ—Ä–∫–∞"]

# === –ë–ê–ó–ê –î–ê–ù–ù–´–• ===
def init_db():
    conn = sqlite3.connect('jobs.db')
    cur = conn.cursor()
    cur.execute('''
        CREATE TABLE IF NOT EXISTS jobs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            position TEXT NOT NULL,
            section TEXT NOT NULL,
            datetime TEXT NOT NULL,
            is_taken INTEGER DEFAULT 0,
            worker_id INTEGER,
            worker_name TEXT
        )
    ''')
    conn.commit()
    conn.close()

def cleanup_old_jobs():
    conn = sqlite3.connect('jobs.db')
    cur = conn.cursor()
    now = datetime.now()
    cur.execute("SELECT id, datetime FROM jobs")
    rows = cur.fetchall()
    for row in rows:
        job_id, dt_str = row
        try:
            job_dt = datetime.strptime(dt_str, "%d.%m.%Y %H:%M")
            if job_dt < now - timedelta(hours=1):
                cur.execute("DELETE FROM jobs WHERE id = ?", (job_id,))
        except:
            pass
    conn.commit()
    conn.close()

# === –°–û–°–¢–û–Ø–ù–ò–Ø ===
class AddJob(StatesGroup):
    position = State()
    section = State()
    datetime = State()

class FindJob(StatesGroup):
    position = State()
    section = State()

# === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ===
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher(bot, storage=MemoryStorage())

# === –ö–õ–ê–í–ò–ê–¢–£–†–´ ===
def get_positions_keyboard():
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    for pos in POSITIONS:
        keyboard.add(pos)
    return keyboard

def get_sections_keyboard():
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    for sec in SECTIONS:
        keyboard.add(sec)
    return keyboard

# === –ö–û–ú–ê–ù–î–´ ===
@dp.message_handler(commands=['start'])
async def start(message: types.Message):
    if message.from_user.id in ADMIN_IDS:
        await message.answer(
            "üõ† –ü—Ä–∏–≤–µ—Ç, –º–∞—Å—Ç–µ—Ä!\n"
            "‚Ä¢ /add_job ‚Äî –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–¥—Ä–∞–±–æ—Ç–∫—É\n"
            "‚Ä¢ /admin ‚Äî –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤—Å–µ –∑–∞—è–≤–∫–∏"
        )
    else:
        await message.answer("üëã –ü—Ä–∏–≤–µ—Ç, –∫–æ–ª–ª–µ–≥–∞!\n‚Ä¢ /find_job ‚Äî –Ω–∞–π—Ç–∏ –ø–æ–¥—Ä–∞–±–æ—Ç–∫—É")

@dp.message_handler(commands=['admin'])
async def admin_panel(message: types.Message):
    if message.from_user.id not in ADMIN_IDS:
        await message.answer("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return
    cleanup_old_jobs()
    conn = sqlite3.connect('jobs.db')
    cur = conn.cursor()
    cur.execute("SELECT id, position, section, datetime, is_taken, worker_name FROM jobs ORDER BY datetime")
    jobs = cur.fetchall()
    conn.close()
    if not jobs:
        await message.answer("–ù–µ—Ç –ø–æ–¥—Ä–∞–±–æ—Ç–æ–∫.")
        return
    text = "üìã –í—Å–µ –ø–æ–¥—Ä–∞–±–æ—Ç–∫–∏:\n\n"
    for j in jobs:
        status = "‚úÖ –ó–∞–Ω—è—Ç–∞" if j[4] else "üïó –°–≤–æ–±–æ–¥–Ω–∞"
        worker = f" ({j[5]})" if j[5] else ""
        text += f"ID {j[0]} | {j[1]} | {j[2]} | {j[3]} | {status}{worker}\n"
    await message.answer(text)

@dp.message_handler(commands=['add_job'])
async def add_job_start(message: types.Message):
    if message.from_user.id not in ADMIN_IDS:
        await message.answer("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤.")
        return
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–æ–ª–∂–Ω–æ—Å—Ç—å:", reply_markup=get_positions_keyboard())
    await AddJob.position.set()

@dp.message_handler(state=AddJob.position)
async def add_job_position(message: types.Message, state: FSMContext):
    if message.text not in POSITIONS:
        await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∏–∑ —Å–ø–∏—Å–∫–∞!", reply_markup=get_positions_keyboard())
        return
    await state.update_data(position=message.text)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —É—á–∞—Å—Ç–æ–∫:", reply_markup=get_sections_keyboard())
    await AddJob.section.set()

@dp.message_handler(state=AddJob.section)
async def add_job_section(message: types.Message, state: FSMContext):
    if message.text not in SECTIONS:
        await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∏–∑ —Å–ø–∏—Å–∫–∞!", reply_markup=get_sections_keyboard())
        return
    await state.update_data(section=message.text)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è: –î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú\n–ü—Ä–∏–º–µ—Ä: 07.04.2025 18:00")
    await AddJob.datetime.set()

@dp.message_handler(state=AddJob.datetime)
async def add_job_datetime(message: types.Message, state: FSMContext):
    try:
        datetime.strptime(message.text, "%d.%m.%Y %H:%M")
    except ValueError:
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: –î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú")
        return
    user_data = await state.get_data()
    position = user_data['position']
    section = user_data['section']
    dt = message.text
    conn = sqlite3.connect('jobs.db')
    cur = conn.cursor()
    cur.execute("INSERT INTO jobs (position, section, datetime) VALUES (?, ?, ?)",
                (position, section, dt))
    conn.commit()
    conn.close()
    await message.answer(f"‚úÖ –ü–æ–¥—Ä–∞–±–æ—Ç–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞!\n{position} | {section} | {dt}")
    await state.finish()

@dp.message_handler(commands=['find_job'])
async def find_job_start(message: types.Message):
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à—É –¥–æ–ª–∂–Ω–æ—Å—Ç—å:", reply_markup=get_positions_keyboard())
    await FindJob.position.set()

@dp.message_handler(state=FindJob.position)
async def find_job_position(message: types.Message, state: FSMContext):
    if message.text not in POSITIONS:
        await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∏–∑ —Å–ø–∏—Å–∫–∞!", reply_markup=get_positions_keyboard())
        return
    await state.update_data(position=message.text)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à —É—á–∞—Å—Ç–æ–∫:", reply_markup=get_sections_keyboard())
    await FindJob.section.set()

@dp.message_handler(state=FindJob.section)
async def find_job_section(message: types.Message, state: FSMContext):
    if message.text not in SECTIONS:
        await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∏–∑ —Å–ø–∏—Å–∫–∞!", reply_markup=get_sections_keyboard())
        return
    user_data = await state.get_data()
    position = user_data['position']
    section = message.text
    cleanup_old_jobs()
    conn = sqlite3.connect('jobs.db')
    cur = conn.cursor()
    cur.execute("""
        SELECT id, datetime FROM jobs 
        WHERE position = ? AND section = ? AND is_taken = 0 
        AND datetime >= ?
        ORDER BY datetime
    """, (position, section, datetime.now().strftime("%d.%m.%Y %H:%M")))
    results = cur.fetchall()
    conn.close()
    if not results:
        await message.answer("üïó –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø–æ–¥—Ä–∞–±–æ—Ç–æ–∫ –Ω–∞ –±–ª–∏–∂–∞–π—à—É—é –Ω–µ–¥–µ–ª—é.")
        await state.finish()
        return
    for job_id, dt in results:
        markup = types.InlineKeyboardMarkup()
        btn = types.InlineKeyboardButton("‚úÖ –ó–∞–ø–∏—Å–∞—Ç—å—Å—è", callback_data=f"take_{job_id}")
        markup.add(btn)
        await message.answer(f"üïó {dt}\n–£—á–∞—Å—Ç–æ–∫: {section}", reply_markup=markup)
    await state.finish()

@dp.callback_query_handler(lambda c: c.data.startswith('take_'))
async def take_job(callback_query: types.CallbackQuery):
    user_id = callback_query.from_user.id
    user_name = callback_query.from_user.full_name
    job_id = int(callback_query.data.split('_')[1])
    conn = sqlite3.connect('jobs.db')
    cur = conn.cursor()
    cur.execute("SELECT is_taken FROM jobs WHERE id = ?", (job_id,))
    row = cur.fetchone()
    if not row or row[0] == 1:
        await callback_query.answer("‚ùå –≠—Ç–∞ –ø–æ–¥—Ä–∞–±–æ—Ç–∫–∞ —É–∂–µ –∑–∞–Ω—è—Ç–∞!", show_alert=True)
        await callback_query.message.delete()
        conn.close()
        return
    cur.execute("UPDATE jobs SET is_taken = 1, worker_id = ?, worker_name = ? WHERE id = ?",
                (user_id, user_name, job_id))
    conn.commit()
    conn.close()
    await callback_query.message.edit_text(
        f"‚úÖ –í—ã –∑–∞–ø–∏—Å–∞–Ω—ã –Ω–∞ –ø–æ–¥—Ä–∞–±–æ—Ç–∫—É!\nID: {job_id}\n–†–∞–±–æ—Ç–Ω–∏–∫: {user_name}"
    )
    await callback_query.answer("–í—ã —É—Å–ø–µ—à–Ω–æ –∑–∞–ø–∏—Å–∞–ª–∏—Å—å!")

if __name__ == '__main__':
    init_db()
    from aiogram import executor
    print("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
    executor.start_polling(dp, skip_updates=True)
